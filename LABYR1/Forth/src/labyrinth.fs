
CREATE LABYRINTH BITSET-SIZE ALLOT
CREATE COORD-SET BITSET-SIZE ALLOT
CREATE VISITED   BITSET-SIZE ALLOT


: COORD>OFFSET ( col,row -- n )
    N * + ;

2VARIABLE DIMENSIONS
2VARIABLE START

: COORD-INCLUDED? ( coord -- f )
    COORD>OFFSET COORD-SET BITSET@ ;

: COORD-INCLUDE! ( coord -- )
    COORD>OFFSET COORD-SET BITSET! ;

: VISITED? ( coord -- f )
    COORD>OFFSET VISITED BITSET@ ;

: VISIT! ( coord -- )
    COORD>OFFSET VISITED BITSET! ;

: INIT-LABYRINTH
    LABYRINTH BITSET-INIT ;

: LABYRINTH-LINE! ( str,count,row -- )
    -ROT 0 DO
        DUP I + C@ [CHAR] . = IF
            OVER I SWAP
            COORD>OFFSET
            LABYRINTH BITSET!
        THEN
    LOOP 2DROP ;

: LABYRINTH-FREE? ( coord -- f )
    COORD>OFFSET LABYRINTH BITSET@ ;

: START-COORD ( -- row,col )
    DIMENSIONS 2@
    FALSE -ROT
    0 SWAP OVER DO
        2DUP DO
        I J LABYRINTH-FREE? IF
            J I START 2!
            DROP TRUE
            LEAVE
        THEN
        LOOP
        DUP IF
            LEAVE
        THEN
    LOOP DROP 2DROP
    START 2@ ;

: ADJACENT-SPACE? ( n,coords -- n|coords,n+1 )
    2DUP VISITED? 0= >R
    2DUP LABYRINTH-FREE? R> AND IF
        ROT 1+
    ELSE
        2DROP
    THEN ;

: NORTH ( coords -- coords' )
    1+ ;

: SOUTH ( coords -- coords' )
    1- ;

: WEST ( coords -- coords' )
    SWAP 1+ SWAP ;

: EAST ( coords -- coords' )
    SWAP 1- SWAP ;

: ADJACENT-SPACES ( coords -- coords1,â€¦,n )
    2>R 0
    2R@ NORTH ADJACENT-SPACE?
    2R@ EAST ADJACENT-SPACE?
    2R@ SOUTH ADJACENT-SPACE?
    2R> WEST ADJACENT-SPACE? ;

: ROPE>CELL ( coords,length -- n )
    16 LSHIFT OR 16 LSHIFT OR ;

: CELL>ROPE ( n -- coords,length )
    DUP 65535 AND SWAP 16 RSHIFT 
    DUP 65535 AND SWAP 16 RSHIFT ;

CREATE ROPE-CELLS N DUP * CELLS ALLOCATE THROW ,

: FREE-ROPE-CELLS
    ROPE-CELLS @ FREE THROW ;

VARIABLE ROPE-START
VARIABLE ROPE-END

: INIT-ROPE-CELLS
    COORD-SET BITSET-INIT
    ROPE-CELLS @ ROPE-START !
    ROPE-CELLS @ ROPE-END ! ;

: .LABYRINTH
    DIMENSIONS 2@
    0 SWAP OVER
    DO 2DUP DO
        I J LABYRINTH-FREE? IF
            [CHAR] .
        ELSE
            [CHAR] #
        THEN
        EMIT
    LOOP CR LOOP 2DROP ;

: MORE-TO-VISIT? ( -- f )
    ROPE-START @ ROPE-END @ < ;

: .TO-VISIT
    ROPE-END @ ROPE-START @ - CELL / .
    ." -- "
    ROPE-START @ @ CELL>ROPE -ROT SWAP . . . CR ; 

: PUSH-ROPE-CELL ( coords,length -- )
    -ROT 2DUP COORD-INCLUDED? 0= IF
        2DUP COORD-INCLUDE!
        ROT ROPE>CELL ROPE-END @ !
        CELL ROPE-END +!
    ELSE
        2DROP DROP
    THEN ;

: POP-ROPE-CELL ( -- coords, length )
    ROPE-START @ @
    CELL ROPE-START +!
    CELL>ROPE ;

VARIABLE LENGTH
2VARIABLE FAR-COORD

: UPDATE-LENGTH ( coord,n -- )
    DUP LENGTH @ > IF
        LENGTH !
        FAR-COORD 2!
    ELSE
        DROP 2DROP
    THEN ;

: (ROPE-LENGTH) ( coords -- )
    INIT-ROPE-CELLS
    VISITED BITSET-INIT
    0 PUSH-ROPE-CELL
    BEGIN
        MORE-TO-VISIT? WHILE
        POP-ROPE-CELL
        DUP 2OVER ROT UPDATE-LENGTH
        1+ >R
        2DUP VISIT!
        ADJACENT-SPACES 0 ?DO
            J PUSH-ROPE-CELL
        LOOP R> DROP
    REPEAT ;

: ROPE-LENGTH ( -- n )
    LENGTH OFF
    START-COORD
    (ROPE-LENGTH)
    FAR-COORD 2@
    (ROPE-LENGTH)
    LENGTH @ ;
    
: READ-LABYRINTH
    READ-INPUT-LINE ASSERT( )
    STR-TOKENS ASSERT( 2 = )
    STR>NUMBER -ROT STR>NUMBER SWAP
    2DUP DIMENSIONS 2!
    0 DO
        READ-INPUT-LINE ASSERT( )
        I LABYRINTH-LINE!
    LOOP DROP ;

DEFER PROCESS-TEST-CASE

: READ-TEST-CASES
    READ-INPUT-LINE ASSERT( )
    STR-TOKENS ASSERT( 1 = )
    STR>NUMBER 0 DO
        INIT-LABYRINTH
        READ-LABYRINTH
        PROCESS-TEST-CASE
    LOOP ;

: COMPUTE-ROPE-LENGTH
    START-COORD
    ROPE-LENGTH
    ." Maximum rope length is "
    0 .R [CHAR] . EMIT CR ;

' COMPUTE-ROPE-LENGTH IS PROCESS-TEST-CASE

: PROCESS
    READ-TEST-CASES
    FREE-ROPE-CELLS ;



