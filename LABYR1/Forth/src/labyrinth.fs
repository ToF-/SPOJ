1000 CONSTANT SIZE-MAX

CREATE LABYRINTH SIZE-MAX DUP * ALLOT
VARIABLE ROW-MAX
VARIABLE COL-MAX

2VARIABLE DIMENSIONS
2VARIABLE START

CREATE COORD-SET SIZE-MAX DUP * 8 / ALLOT 

: INIT-COORD-SET
    COORD-SET SIZE-MAX DUP * 8 / ERASE ;

: COORD-INCLUDED? ( coord -- f )
    * 8 /MOD COORD-SET + C@
    SWAP 1 SWAP LSHIFT AND ;

: COORD-INCLUDE! ( coord -- )
    * 8 /MOD COORD-SET + DUP C@
    ROT 1 SWAP LSHIFT -1 XOR 255 AND
    AND SWAP C! ;

: INIT-LABYRINTH
    LABYRINTH SIZE-MAX DUP * ERASE ;

: LABYRINTH^ ( coords -- addr )
    SIZE-MAX * + LABYRINTH + ;

: LABYRINTH-LINE! ( str,count,row -- )
    SIZE-MAX * LABYRINTH +
    SWAP CMOVE ;

: LABYRINTH-BLOCK! ( coord -- )
    LABYRINTH^ [CHAR] # SWAP C! ;

: LABYRINTH-FREE? ( coord -- f )
    LABYRINTH^ C@ [CHAR] . = ;

: START-COORD ( -- row,col )
    DIMENSIONS 2@
    FALSE -ROT
    0 SWAP OVER DO
        2DUP DO
        I J LABYRINTH-FREE? IF
            J I START 2!
            DROP TRUE
            LEAVE
        THEN
        LOOP
        DUP IF
            LEAVE
        THEN
    LOOP DROP 2DROP
    START 2@ ;

: ADJACENT-SPACE? ( n,coords -- n|coords,n+1 )
    2DUP LABYRINTH-FREE? IF
        ROT 1+
    ELSE
        2DROP
    THEN ;

: NORTH ( coords -- coords' )
    1+ ;

: SOUTH ( coords -- coords' )
    1- ;

: WEST ( coords -- coords' )
    SWAP 1+ SWAP ;

: EAST ( coords -- coords' )
    SWAP 1- SWAP ;

: ADJACENT-SPACES ( coords -- coords1,â€¦,n )
    2>R 0
    2R@ NORTH ADJACENT-SPACE?
    2R@ EAST ADJACENT-SPACE?
    2R@ SOUTH ADJACENT-SPACE?
    2R> WEST ADJACENT-SPACE? ;

: ROPE>CELL ( coords,length -- n )
    16 LSHIFT OR 16 LSHIFT OR ;

: CELL>ROPE ( n -- coords,length )
    DUP 65535 AND SWAP 16 RSHIFT 
    DUP 65535 AND SWAP 16 RSHIFT ;

CREATE ROPE-CELLS SIZE-MAX DUP * CELLS ALLOCATE THROW ,

: FREE-ROPE-CELLS
    ROPE-CELLS @ FREE THROW ;

VARIABLE ROPE-START
VARIABLE ROPE-END

: INIT-ROPE-CELLS
    ROPE-CELLS @ ROPE-START !
    ROPE-CELLS @ ROPE-END ! ;

: .LABYRINTH
    DIMENSIONS 2@
    0 SWAP OVER
    DO 2DUP DO
        I J LABYRINTH^ C@ EMIT
    LOOP CR LOOP 2DROP ;

: MORE-TO-VISIT? ( -- f )
    ROPE-START @ ROPE-END @ < ;

: .TO-VISIT
    ROPE-END @ ROPE-START @ - CELL / .
    ." -- "
    ROPE-START @ @ CELL>ROPE -ROT SWAP . . . CR 
    KEY DROP ;

: PUSH-ROPE-CELL ( coords,length -- )
    ROPE>CELL ROPE-END @ !
    CELL ROPE-END +!  ;

: POP-ROPE-CELL ( -- coords, length )
    ROPE-START @ @
    CELL ROPE-START +!
    CELL>ROPE ;

VARIABLE LENGTH

: UPDATE-LENGTH ( n -- )
    LENGTH @ MAX LENGTH ! ;

: ROPE-LENGTH ( coords -- n )
    LENGTH OFF
    INIT-ROPE-CELLS
    START-COORD 0 PUSH-ROPE-CELL
    BEGIN
        .TO-VISIT
        MORE-TO-VISIT? WHILE
        POP-ROPE-CELL 
        DUP UPDATE-LENGTH 1+ >R
        2DUP LABYRINTH-BLOCK!
        ADJACENT-SPACES 0 ?DO
            J PUSH-ROPE-CELL
        LOOP R> DROP
    REPEAT
    LENGTH @ ;
    
: READ-LABYRINTH
    READ-INPUT-LINE ASSERT( )
    STR-TOKENS ASSERT( 2 = )
    STR>NUMBER -ROT STR>NUMBER SWAP
    2DUP DIMENSIONS 2!
    0 DO
        READ-INPUT-LINE ASSERT( )
        I LABYRINTH-LINE!
    LOOP DROP ;

DEFER PROCESS-TEST-CASE

: READ-TEST-CASES
    READ-INPUT-LINE ASSERT( )
    STR-TOKENS ASSERT( 1 = )
    STR>NUMBER 0 DO
        INIT-LABYRINTH
        READ-LABYRINTH
        PROCESS-TEST-CASE
    LOOP ;

: COMPUTE-ROPE-LENGTH
    START-COORD
    ROPE-LENGTH
    ." Maximum rope length is "
    0 .R [CHAR] . EMIT CR ;

' COMPUTE-ROPE-LENGTH IS PROCESS-TEST-CASE

: PROCESS
    READ-TEST-CASES
    FREE-ROPE-CELLS ;



